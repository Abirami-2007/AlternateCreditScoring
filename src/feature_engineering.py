# src/feature_engineering.py
# ================================================================
# STEP 2 — Feature Engineering for all 4 datasets
# Run: python src/feature_engineering.py
# ================================================================

import pandas as pd
import numpy as np
from sklearn.preprocessing import LabelEncoder
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from config import PATHS, ALL_FEATURES


def fill_missing_features(df, all_features):
    """Add NaN columns for any features not generated by this dataset."""
    for col in all_features:
        if col not in df.columns:
            df[col] = np.nan
    return df


# ================================================================
# DATASET 1 — HOME CREDIT
# ================================================================
def engineer_home_credit():
    print("\n" + "="*55)
    print(" Engineering Home Credit Features")
    print("="*55)

    df = pd.read_csv(PATHS["hc_main"])
    print(f"  Main app loaded: {df.shape}")

    out = pd.DataFrame()
    out["source_id"]      = df["SK_ID_CURR"].astype(str) + "_HC"
    out["TARGET"]         = df["TARGET"]
    out["source_dataset"] = "home_credit"

    # ── Income & Loan ──
    out["income_total"]         = df["AMT_INCOME_TOTAL"]
    out["credit_amount"]        = df["AMT_CREDIT"]
    out["annuity_amount"]       = df["AMT_ANNUITY"]
    out["credit_to_income"]     = df["AMT_CREDIT"] / (df["AMT_INCOME_TOTAL"] + 1)
    out["annuity_to_income"]    = df["AMT_ANNUITY"] / (df["AMT_INCOME_TOTAL"] + 1)
    out["credit_to_goods"]      = df["AMT_CREDIT"] / (df["AMT_GOODS_PRICE"] + 1)
    out["loan_amount_to_goods"] = df["AMT_CREDIT"] / (df["AMT_GOODS_PRICE"] + 1)
    out["income_per_person"]    = df["AMT_INCOME_TOTAL"] / (df["CNT_FAM_MEMBERS"] + 1)
    term_proxy                  = (df["AMT_CREDIT"] / (df["AMT_ANNUITY"] + 1)).clip(1, 360)
    out["credit_per_month"]     = df["AMT_CREDIT"] / term_proxy

    # ── External Scores (alternative credit signals) ──
    ext = df[["EXT_SOURCE_1","EXT_SOURCE_2","EXT_SOURCE_3"]]
    out["ext_source_1"]    = df["EXT_SOURCE_1"]
    out["ext_source_2"]    = df["EXT_SOURCE_2"]
    out["ext_source_3"]    = df["EXT_SOURCE_3"]
    out["ext_source_mean"] = ext.mean(axis=1)
    out["ext_source_std"]  = ext.std(axis=1)
    out["ext_source_min"]  = ext.min(axis=1)
    out["ext_source_count"]= ext.notna().sum(axis=1)

    # ── Docs & Enquiries ──
    doc_cols = [c for c in df.columns if "FLAG_DOCUMENT" in c]
    out["docs_submission_rate"] = df[doc_cols].sum(axis=1) / len(doc_cols)
    enq_cols = [c for c in df.columns if "AMT_REQ_CREDIT_BUREAU" in c]
    out["total_enquiries"]      = df[enq_cols].sum(axis=1)
    out["recent_enquiries_1yr"] = df.get("AMT_REQ_CREDIT_BUREAU_YEAR",
                                         pd.Series(np.nan, index=df.index))

    # ── Demographics & Stability ──
    out["age_years"]             = (-df["DAYS_BIRTH"] / 365).round(1)
    out["employment_years"]      = (-df["DAYS_EMPLOYED"].clip(upper=0) / 365).round(1)
    out["employed_flag"]         = (df["DAYS_EMPLOYED"] < 0).astype(int)
    out["is_employed"]           = out["employed_flag"]
    out["own_car_flag"]          = (df["FLAG_OWN_CAR"] == "Y").astype(int)
    out["own_realty_flag"]       = (df["FLAG_OWN_REALTY"] == "Y").astype(int)
    out["family_members"]        = df["CNT_FAM_MEMBERS"]
    out["children_count"]        = df["CNT_CHILDREN"]
    out["region_rating"]         = df["REGION_RATING_CLIENT"]
    out["live_work_same_region"] = (df["REG_CITY_NOT_LIVE_CITY"] == 0).astype(int)
    out["has_telephone"]         = df["FLAG_MOBIL"]

    # ── Encode contract type ──
    le = LabelEncoder()
    out["name_contract_type"] = le.fit_transform(df["NAME_CONTRACT_TYPE"].astype(str))

    # ── BUREAU ──
    print("  Processing bureau.csv...")
    bureau  = pd.read_csv(PATHS["hc_bureau"])
    bur_bal = pd.read_csv(PATHS["hc_bureau_bal"])

    bb = bur_bal.groupby("SK_ID_BUREAU").agg(
        bad_months = ("STATUS", lambda x: x.isin(["2","3","4","5"]).sum()),
        dpd_months = ("STATUS", lambda x: (x == "X").sum()),
    ).reset_index()
    bureau = bureau.merge(bb, on="SK_ID_BUREAU", how="left")

    bur_agg = bureau.groupby("SK_ID_CURR").agg(
        bureau_credit_day_overdue_max = ("CREDIT_DAY_OVERDUE", "max"),
        bureau_credit_sum_overdue     = ("AMT_CREDIT_SUM_OVERDUE", "sum"),
        bureau_debt_sum               = ("AMT_CREDIT_SUM_DEBT", "sum"),
        bureau_credit_sum             = ("AMT_CREDIT_SUM", "sum"),
        bureau_bad_status_months      = ("bad_months", "sum"),
        bureau_dpd_months_mean        = ("dpd_months", "mean"),
        bureau_active                 = ("CREDIT_ACTIVE", lambda x: (x=="Active").sum()),
        bureau_total                  = ("CREDIT_ACTIVE", "count"),
    ).reset_index()
    bur_agg["bureau_debt_to_credit_ratio"] = (
        bur_agg["bureau_debt_sum"] / (bur_agg["bureau_credit_sum"] + 1))
    bur_agg["bureau_active_credit_ratio"]  = (
        bur_agg["bureau_active"] / (bur_agg["bureau_total"] + 1))

    bm = bur_agg.set_index("SK_ID_CURR")
    ids = df["SK_ID_CURR"].values
    for feat in ["bureau_credit_day_overdue_max","bureau_credit_sum_overdue",
                 "bureau_debt_to_credit_ratio","bureau_bad_status_months",
                 "bureau_dpd_months_mean","bureau_active_credit_ratio"]:
        out[feat] = bm[feat].reindex(ids).values if feat in bm else np.nan

    # ── INSTALLMENTS ──
    print("  Processing installments_payments.csv...")
    inst = pd.read_csv(PATHS["hc_installments"])
    inst["days_late"]   = inst["DAYS_ENTRY_PAYMENT"] - inst["DAYS_INSTALMENT"]
    inst["pay_ratio"]   = inst["AMT_PAYMENT"] / (inst["AMT_INSTALMENT"] + 1)
    inst["late_flag"]   = (inst["days_late"] > 0).astype(int)
    inst["early_flag"]  = (inst["days_late"] < 0).astype(int)
    inst["ontime_flag"] = (inst["days_late"] == 0).astype(int)

    ia = inst.groupby("SK_ID_CURR").agg(
        i_late      = ("late_flag", "sum"),
        i_early     = ("early_flag", "sum"),
        i_ontime    = ("ontime_flag", "sum"),
        i_total     = ("late_flag", "count"),
        i_dlate_max = ("days_late", "max"),
        i_dlate_mean= ("days_late", "mean"),
        i_pr_mean   = ("pay_ratio", "mean"),
        i_pr_std    = ("pay_ratio", "std"),
    ).reset_index()
    ia["inst_late_payment_rate"]   = ia["i_late"]   / (ia["i_total"] + 1)
    ia["inst_early_payment_rate"]  = ia["i_early"]  / (ia["i_total"] + 1)
    ia["inst_on_time_rate"]        = ia["i_ontime"] / (ia["i_total"] + 1)
    ia["inst_payment_consistency"] = 1 / (ia["i_pr_std"] + 0.01)
    ia["inst_days_late_max"]       = ia["i_dlate_max"]
    ia["inst_days_late_mean"]      = ia["i_dlate_mean"]
    ia["inst_payment_ratio_mean"]  = ia["i_pr_mean"]
    ia["inst_payment_ratio_std"]   = ia["i_pr_std"]

    im = ia.set_index("SK_ID_CURR")
    for feat in ["inst_late_payment_rate","inst_early_payment_rate","inst_on_time_rate",
                 "inst_payment_consistency","inst_days_late_max","inst_days_late_mean",
                 "inst_payment_ratio_mean","inst_payment_ratio_std"]:
        out[feat] = im[feat].reindex(ids).values if feat in im else np.nan

    # ── POS CASH ──
    print("  Processing POS_CASH_balance.csv...")
    pos = pd.read_csv(PATHS["hc_pos"])
    pos["dpd_flag"] = (pos["SK_DPD"] > 0).astype(int)
    pa = pos.groupby("SK_ID_CURR").agg(
        pos_dpd_sum         = ("dpd_flag", "sum"),
        pos_total           = ("dpd_flag", "count"),
        pos_sk_dpd_max      = ("SK_DPD", "max"),
        pos_inst_mean       = ("CNT_INSTALMENT", "mean"),
        pos_inst_future_mean= ("CNT_INSTALMENT_FUTURE", "mean"),
    ).reset_index()
    pa["pos_dpd_rate"]        = pa["pos_dpd_sum"] / (pa["pos_total"] + 1)
    pa["pos_dpd_occurrences"] = pa["pos_dpd_sum"]
    pa["pos_completion_ratio"]= 1 - (pa["pos_inst_future_mean"] / (pa["pos_inst_mean"] + 1))

    pm = pa.set_index("SK_ID_CURR")
    for feat in ["pos_dpd_rate","pos_dpd_occurrences","pos_sk_dpd_max","pos_completion_ratio"]:
        out[feat] = pm[feat].reindex(ids).values if feat in pm else np.nan

    # ── CREDIT CARD ──
    print("  Processing credit_card_balance.csv...")
    cc = pd.read_csv(PATHS["hc_cc"])
    cc["util"]     = cc["AMT_BALANCE"] / (cc["AMT_CREDIT_LIMIT_ACTUAL"] + 1)
    cc["pay_rate"] = cc["AMT_PAYMENT_CURRENT"] / (cc["AMT_INST_MIN_REGULARITY"] + 1)
    cc["draw_rate"]= cc["AMT_DRAWINGS_CURRENT"] / (cc["AMT_CREDIT_LIMIT_ACTUAL"] + 1)
    cc["atm_rate"] = cc["AMT_DRAWINGS_ATM_CURRENT"] / (cc["AMT_DRAWINGS_CURRENT"] + 1)

    ca = cc.groupby("SK_ID_CURR").agg(
        cc_utilization_mean    = ("util", "mean"),
        cc_utilization_max     = ("util", "max"),
        cc_payment_rate_mean   = ("pay_rate", "mean"),
        cc_payment_rate_std    = ("pay_rate", "std"),
        cc_dpd_mean            = ("SK_DPD", "mean"),
        cc_dpd_max             = ("SK_DPD", "max"),
        cc_drawing_rate_mean   = ("draw_rate", "mean"),
        cc_atm_to_total_drawing= ("atm_rate", "mean"),
    ).reset_index()

    cm = ca.set_index("SK_ID_CURR")
    for feat in ["cc_utilization_mean","cc_utilization_max","cc_payment_rate_mean",
                 "cc_payment_rate_std","cc_dpd_mean","cc_dpd_max",
                 "cc_drawing_rate_mean","cc_atm_to_total_drawing"]:
        out[feat] = cm[feat].reindex(ids).values if feat in cm else np.nan

    # ── PREVIOUS APPLICATIONS ──
    print("  Processing previous_application.csv...")
    prev = pd.read_csv(PATHS["hc_prev"])
    prev["approved"] = (prev["NAME_CONTRACT_STATUS"] == "Approved").astype(int)
    prev["refused"]  = (prev["NAME_CONTRACT_STATUS"] == "Refused").astype(int)
    pva = prev.groupby("SK_ID_CURR").agg(
        prev_total    = ("SK_ID_PREV", "count"),
        prev_approved = ("approved", "sum"),
        prev_refused  = ("refused", "sum"),
    ).reset_index()
    pva["prev_approval_rate"]      = pva["prev_approved"] / (pva["prev_total"] + 1)
    pva["prev_refusal_rate"]       = pva["prev_refused"]  / (pva["prev_total"] + 1)
    pva["prev_total_applications"] = pva["prev_total"]

    pvm = pva.set_index("SK_ID_CURR")
    for feat in ["prev_approval_rate","prev_refusal_rate","prev_total_applications"]:
        out[feat] = pvm[feat].reindex(ids).values if feat in pvm else np.nan
    out["has_loan_history"] = out["prev_total_applications"].notna().astype(int)

    out = fill_missing_features(out, ALL_FEATURES)
    print(f"   Home Credit done: {len(out):,} rows")
    return out


# ================================================================
# DATASET 2 — GIVE ME SOME CREDIT
# ================================================================
def engineer_gmsc():
    print("\n" + "="*55)
    print(" Engineering Give Me Some Credit Features")
    print("="*55)

    df = pd.read_csv(PATHS["gmsc"], index_col=0)
    df.columns = [c.strip() for c in df.columns]
    df = df.rename(columns={
        "SeriousDlqin2yrs":                       "TARGET",
        "RevolvingUtilizationOfUnsecuredLines":    "revolving_util",
        "age":                                     "age_years",
        "NumberOfTime30-59DaysPastDueNotWorse":    "late_30_59",
        "DebtRatio":                               "debt_ratio",
        "MonthlyIncome":                           "monthly_income",
        "NumberOfOpenCreditLinesAndLoans":         "open_credits",
        "NumberOfTimes90DaysLate":                 "late_90plus",
        "NumberRealEstateLoansOrLines":            "real_estate_loans",
        "NumberOfTime60-89DaysPastDueNotWorse":    "late_60_89",
        "NumberOfDependents":                      "dependents",
    })
    print(f"  Loaded: {df.shape}")

    out = pd.DataFrame()
    out["source_id"]      = df.index.astype(str) + "_GMSC"
    out["TARGET"]         = df["TARGET"]
    out["source_dataset"] = "give_me_some_credit"

    out["age_years"]         = df["age_years"]
    out["income_total"]      = df["monthly_income"] * 12
    out["family_members"]    = df["dependents"] + 1
    out["children_count"]    = df["dependents"]
    out["income_per_person"] = (df["monthly_income"] * 12) / (df["dependents"] + 2)
    out["debt_ratio"]        = df["debt_ratio"]
    out["credit_to_income"]  = df["debt_ratio"]
    out["cc_utilization_mean"] = df["revolving_util"].clip(0, 5)
    out["existing_credits_count"] = df["open_credits"]
    out["own_realty_flag"]   = (df["real_estate_loans"] > 0).astype(int)
    out["bureau_active_credit_ratio"] = df["open_credits"] / (df["open_credits"] + 1)

    total_late = df["late_30_59"] + df["late_60_89"] + df["late_90plus"]
    out["inst_late_payment_rate"] = (total_late / 37).clip(0, 1)
    out["inst_on_time_rate"]      = 1 - out["inst_late_payment_rate"]
    out["has_past_delays"]        = (total_late > 0).astype(int)
    out["inst_days_late_max"]     = np.where(df["late_90plus"] > 0, 90,
                                    np.where(df["late_60_89"] > 0, 60,
                                    np.where(df["late_30_59"] > 0, 30, 0)))
    out["credit_history_ordinal"] = np.where(df["late_90plus"] > 0, 0,
                                    np.where(df["late_60_89"] > 0, 1,
                                    np.where(df["late_30_59"] > 0, 2, 4)))
    out["has_critical_account"]   = (df["late_90plus"] > 2).astype(int)
    out["has_loan_history"]       = (df["open_credits"] > 0).astype(int)

    out = fill_missing_features(out, ALL_FEATURES)
    print(f"   Give Me Some Credit done: {len(out):,} rows")
    return out


# ================================================================
# DATASET 3 — LENDING CLUB
# ================================================================
def engineer_lending_club():
    print("\n" + "="*55)
    print(" Engineering Lending Club Features")
    print("="*55)

    needed = ["loan_amnt","term","installment","emp_length","home_ownership",
              "annual_inc","loan_status","purpose","dti","delinq_2yrs",
              "open_acc","revol_util","total_acc","revol_bal","tot_cur_bal",
              "num_accts_ever_120_pd","pct_tl_nvr_dlq","pub_rec","mort_acc"]

    df = pd.read_csv(PATHS["lc"],
                     usecols=lambda c: c in needed,
                     low_memory=False)

    active = ["Current","In Grace Period","Late (16-30 days)","Late (31-120 days)","Issued"]
    defaults = ["Charged Off","Default",
                "Does not meet the credit policy. Status:Charged Off"]
    df = df[~df["loan_status"].isin(active)].copy()
    df["TARGET"] = df["loan_status"].isin(defaults).astype(int)
    print(f"  Loaded: {df.shape} (completed loans only)")

    out = pd.DataFrame()
    out["source_id"]      = df.index.astype(str) + "_LC"
    out["TARGET"]         = df["TARGET"]
    out["source_dataset"] = "lending_club"

    out["income_total"]    = df["annual_inc"]
    out["credit_amount"]   = df["loan_amnt"]
    out["annuity_amount"]  = df["installment"]
    out["credit_to_income"]= df["loan_amnt"] / (df["annual_inc"] + 1)
    out["installment_rate_pct"] = df["dti"]
    out["debt_ratio"]      = df["dti"] / 100
    df["term_months"]      = df["term"].str.extract(r"(\d+)").astype(float)
    out["credit_per_month"]= df["loan_amnt"] / (df["term_months"] + 1)
    out["annuity_to_income"]= (df["installment"] * 12) / (df["annual_inc"] + 1)

    out["has_past_delays"]        = (df["delinq_2yrs"] > 0).astype(int)
    out["inst_late_payment_rate"] = (df["delinq_2yrs"] / 25).clip(0, 1)
    out["inst_on_time_rate"]      = 1 - out["inst_late_payment_rate"]
    n120 = df.get("num_accts_ever_120_pd", pd.Series(0, index=df.index))
    out["inst_days_late_max"]     = np.where(n120 > 0, 120,
                                    np.where(df["delinq_2yrs"] > 0, 30, 0))
    out["credit_history_ordinal"] = np.where(n120 > 0, 0,
                                    np.where(df["delinq_2yrs"] > 0, 2, 4))
    out["has_critical_account"]   = (n120 > 0).astype(int)
    pct = df.get("pct_tl_nvr_dlq", pd.Series(np.nan, index=df.index))
    out["prev_approval_rate"]     = pct / 100

    out["cc_utilization_mean"] = pd.to_numeric(
        df["revol_util"].astype(str).str.replace("%",""), errors="coerce") / 100
    out["existing_credits_count"]     = df["open_acc"]
    out["bureau_active_credit_ratio"] = df["open_acc"] / (df["total_acc"] + 1)
    out["bureau_debt_to_credit_ratio"]= df["revol_bal"] / (df["tot_cur_bal"] + 1)
    out["total_enquiries"]            = df["pub_rec"]
    out["own_realty_flag"]            = df["home_ownership"].isin(["MORTGAGE","OWN"]).astype(int)
    out["owns_house"]                 = (df["home_ownership"] == "OWN").astype(int)

    emp_map = {"< 1 year":1,"1 year":2,"2 years":2,"3 years":2,"4 years":3,
               "5 years":3,"6 years":3,"7 years":3,"8 years":4,"9 years":4,
               "10+ years":4,"n/a":0}
    out["employment_stability"] = df["emp_length"].map(emp_map).fillna(0)
    out["employed_flag"]        = (df["emp_length"] != "n/a").astype(int)
    out["is_employed"]          = out["employed_flag"]
    out["senior_employee"]      = (out["employment_stability"] >= 4).astype(int)

    high_risk = ["small_business","vacation","moving","medical","other"]
    out["loan_purpose_high_risk"] = df["purpose"].isin(high_risk).astype(int)
    le = LabelEncoder()
    out["loan_purpose_encoded"]   = le.fit_transform(df["purpose"].astype(str))
    out["has_loan_history"]       = 1

    out = fill_missing_features(out, ALL_FEATURES)
    print(f"  Lending Club done: {len(out):,} rows")
    return out


# ================================================================
# DATASET 4 — PKDD CZECH
# ================================================================
def engineer_pkdd():
    print("\n" + "="*55)
    print(" Engineering PKDD Czech Features")
    print("="*55)

    loan    = pd.read_csv(PATHS["pkdd_loan"],    sep=";")
    trans   = pd.read_csv(PATHS["pkdd_trans"],   sep=";")
    account = pd.read_csv(PATHS["pkdd_account"], sep=";")
    print(f"  Loans: {len(loan)} | Transactions: {len(trans)} | Accounts: {len(account)}")

    loan["TARGET"] = loan["status"].isin(["B","D"]).astype(int)

    trans["is_credit"] = (trans["type"] == "PRIJEM").astype(int)
    trans["is_debit"]  = (trans["type"] == "VYDAJ").astype(int)
    trans["neg_bal"]   = (trans["balance"] < 0).astype(int)

    t_agg = trans.groupby("account_id").agg(
        trans_count   = ("trans_id", "count"),
        mean_balance  = ("balance", "mean"),
        min_balance   = ("balance", "min"),
        std_balance   = ("balance", "std"),
        neg_bal_count = ("neg_bal", "sum"),
        total_credit  = ("amount", "sum"),
    ).reset_index()
    t_agg["balance_consistency"] = 1 / (t_agg["std_balance"] + 1)
    t_agg["neg_balance_rate"]    = t_agg["neg_bal_count"] / (t_agg["trans_count"] + 1)

    merged = loan.merge(account, on="account_id", how="left")
    merged = merged.merge(t_agg, on="account_id", how="left")

    out = pd.DataFrame()
    out["source_id"]      = merged["loan_id"].astype(str) + "_PKDD"
    out["TARGET"]         = merged["TARGET"]
    out["source_dataset"] = "pkdd_czech"

    out["credit_amount"]    = merged["amount"]
    out["credit_per_month"] = merged["amount"] / (merged["duration"] + 1)
    out["annuity_amount"]   = merged["payments"]
    out["income_total"]     = merged["total_credit"]
    out["credit_to_income"] = merged["amount"] / (merged["total_credit"] + 1)
    out["annuity_to_income"]= merged["payments"] / (merged["total_credit"] / 12 + 1)

    # Alternative signals from transaction behaviour
    out["checking_account_ordinal"] = pd.cut(
        merged["mean_balance"], bins=[-np.inf,0,200,1000,np.inf],
        labels=[1,2,3,4]).astype(float)
    out["has_checking_account"]  = 1
    out["has_savings"]           = (merged["mean_balance"] > 500).astype(int)
    out["savings_above_500"]     = out["has_savings"]
    out["savings_account_ordinal"]= (
        (merged["mean_balance"] > 200).astype(int) +
        (merged["mean_balance"] > 500).astype(int) +
        (merged["mean_balance"] > 1000).astype(int)).astype(float)

    out["inst_payment_consistency"] = merged["balance_consistency"]
    out["inst_late_payment_rate"]   = merged["neg_balance_rate"]
    out["inst_on_time_rate"]        = 1 - merged["neg_balance_rate"]
    out["has_past_delays"]          = (merged["min_balance"] < 0).astype(int)
    out["inst_days_late_max"]       = np.where(merged["min_balance"] < -500, 60,
                                      np.where(merged["min_balance"] < 0, 30, 0))
    out["credit_history_ordinal"]   = np.where(out["has_past_delays"] == 1, 2, 4)
    out["has_critical_account"]     = (merged["min_balance"] < -1000).astype(int)

    out["stability_score"] = (
        out["checking_account_ordinal"].fillna(0) +
        out["savings_account_ordinal"].fillna(0) +
        out["has_savings"].fillna(0))
    out["has_loan_history"] = 1

    out = fill_missing_features(out, ALL_FEATURES)
    print(f"   PKDD Czech done: {len(out):,} rows")
    return out


# ================================================================
# MERGE ALL
# ================================================================
def merge_all(hc, gmsc, lc, pkdd):
    print("\n" + "="*55)
    print(" MERGING ALL 4 DATASETS")
    print("="*55)

    merged = pd.concat([hc, gmsc, lc, pkdd],
                       axis=0, ignore_index=True, sort=False)

    print(f"\n  Dataset breakdown:")
    print(merged["source_dataset"].value_counts().to_string())
    print(f"\n  Total rows:      {len(merged):,}")
    print(f"  Total columns:   {merged.shape[1]}")
    print(f"  Default rate:    {merged['TARGET'].mean():.2%}")

    os.makedirs("outputs", exist_ok=True)
    merged.to_csv(PATHS["output_merged"], index=False)
    print(f"\n Saved: {PATHS['output_merged']}")
    return merged


if __name__ == "__main__":
    hc   = engineer_home_credit()
    gmsc = engineer_gmsc()
    lc   = engineer_lending_club()
    pkdd = engineer_pkdd()
    merged = merge_all(hc, gmsc, lc, pkdd)
